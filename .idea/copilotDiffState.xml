<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/arsip/ui/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/arsip/ui/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.arsip.ui.home&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.arsip.data.Book&#10;import com.example.arsip.data.BooksRepository&#10;import com.example.arsip.data.ProfileRepository&#10;import com.google.android.gms.maps.model.LatLng&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import kotlin.math.atan2&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;import kotlin.math.sqrt&#10;&#10;data class HomeState(&#10;    val userName: String = &quot;User&quot;,&#10;    val userPhotoUrl: String? = null,&#10;    val searchQuery: String = &quot;&quot;,&#10;    val selectedFilter: String = &quot;terdekat&quot;,&#10;    val radiusKm: Float = 5f,&#10;    val userLocation: LatLng? = null,&#10;    val allBooks: List&lt;Book&gt; = emptyList(),&#10;    val nearbyBooks: List&lt;Book&gt; = emptyList(),&#10;    val highlightedBooks: List&lt;Book&gt; = emptyList(),&#10;    val isLoading: Boolean = true,&#10;    val errorMessage: String? = null&#10;) {&#10;    fun calculateDistance(book: Book): String {&#10;        if (userLocation == null || book.lat == null || book.lng == null) {&#10;            return book.addressText.split(&quot;,&quot;).firstOrNull()?.trim() ?: &quot;Lokasi tidak diketahui&quot;&#10;        }&#10;&#10;        val distance = calculateDistanceInKm(&#10;            userLocation.latitude,&#10;            userLocation.longitude,&#10;            book.lat,&#10;            book.lng&#10;        )&#10;&#10;        return when {&#10;            distance &lt; 1.0 -&gt; &quot;${(distance * 1000).toInt()} m&quot;&#10;            distance &lt; 10.0 -&gt; String.format(&quot;%.1f km&quot;, distance)&#10;            else -&gt; &quot;${distance.toInt()} km&quot;&#10;        }&#10;    }&#10;&#10;    private fun calculateDistanceInKm(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Double {&#10;        val earthRadius = 6371.0&#10;        val dLat = Math.toRadians(lat2 - lat1)&#10;        val dLng = Math.toRadians(lng2 - lng1)&#10;        val a = sin(dLat / 2) * sin(dLat / 2) +&#10;                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *&#10;                sin(dLng / 2) * sin(dLng / 2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;}&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val booksRepository: BooksRepository,&#10;    private val profileRepository: ProfileRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(HomeState())&#10;    val state: StateFlow&lt;HomeState&gt; = _state.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            try {&#10;                loadUserProfile()&#10;                loadBooks()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Init error&quot;, e)&#10;                _state.update { it.copy(isLoading = false, userName = &quot;User&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            try {&#10;                profileRepository.meFlow()&#10;                    .catch { e -&gt;&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error loading profile&quot;, e)&#10;                        emit(null)&#10;                    }&#10;                    .collectLatest { userProfile -&gt;&#10;                        val userLocation = if (userProfile?.latitude != 0.0 &amp;&amp; userProfile?.longitude != 0.0) {&#10;                            LatLng(userProfile?.latitude ?: 0.0, userProfile?.longitude ?: 0.0)&#10;                        } else {&#10;                            // Default ke Jakarta jika tidak ada lokasi user&#10;                            LatLng(-6.2088, 106.8456)&#10;                        }&#10;&#10;                        _state.update {&#10;                            it.copy(&#10;                                userName = userProfile?.displayName?.ifBlank { &quot;User&quot; } ?: &quot;User&quot;,&#10;                                userPhotoUrl = userProfile?.photoUrl,&#10;                                userLocation = userLocation&#10;                            )&#10;                        }&#10;&#10;                        // Reapply filters setelah mendapat lokasi user&#10;                        applyFilters()&#10;                    }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error in loadUserProfile&quot;, e)&#10;                _state.update {&#10;                    it.copy(&#10;                        userName = &quot;User&quot;,&#10;                        userLocation = LatLng(-6.2088, 106.8456) // Default Jakarta&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadBooks() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _state.update { it.copy(isLoading = true, errorMessage = null) }&#10;&#10;                booksRepository.allBooksFlow()&#10;                    .catch { e -&gt;&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error loading books&quot;, e)&#10;                        emit(emptyList())&#10;                    }&#10;                    .collectLatest { books -&gt;&#10;                        try {&#10;                            val filtered = filterBooks(books)&#10;                            _state.update { currentState -&gt;&#10;                                currentState.copy(&#10;                                    allBooks = books,&#10;                                    nearbyBooks = filtered,&#10;                                    highlightedBooks = books.filter { it.isAvailable }.take(5),&#10;                                    isLoading = false,&#10;                                    errorMessage = null&#10;                                )&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;HomeViewModel&quot;, &quot;Error filtering books&quot;, e)&#10;                            _state.update {&#10;                                it.copy(&#10;                                    allBooks = books,&#10;                                    nearbyBooks = books,&#10;                                    highlightedBooks = books.take(5),&#10;                                    isLoading = false&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error in loadBooks&quot;, e)&#10;                _state.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onSearchQueryChange(query: String) {&#10;        _state.update { it.copy(searchQuery = query) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onFilterSelect(filter: String) {&#10;        _state.update { it.copy(selectedFilter = filter) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onRadiusChange(radius: Float) {&#10;        _state.update { it.copy(radiusKm = radius) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onLocationPermissionGranted() {&#10;        val defaultLocation = LatLng(-6.2088, 106.8456)&#10;        _state.update { it.copy(userLocation = defaultLocation) }&#10;        applyFilters()&#10;    }&#10;&#10;    private fun applyFilters() {&#10;        try {&#10;            val currentState = _state.value&#10;            val filtered = filterBooks(currentState.allBooks)&#10;            _state.update { it.copy(nearbyBooks = filtered) }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error applying filters&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun filterBooks(books: List&lt;Book&gt;): List&lt;Book&gt; {&#10;        val currentState = _state.value&#10;&#10;        // ✅ FILTER 1: Hanya tampilkan buku yang tersedia (isAvailable = true)&#10;        var filteredBooks = books.filter { it.isAvailable }&#10;&#10;        // ✅ FILTER 2: Filter berdasarkan search query&#10;        if (currentState.searchQuery.isNotBlank()) {&#10;            val query = currentState.searchQuery.lowercase()&#10;            filteredBooks = filteredBooks.filter { book -&gt;&#10;                book.title.lowercase().contains(query) ||&#10;                book.author.lowercase().contains(query) ||&#10;                book.category.lowercase().contains(query) ||&#10;                book.desc.lowercase().contains(query)&#10;            }&#10;        }&#10;&#10;        // ✅ FILTER 3: Filter berdasarkan lokasi user dan jarak maksimal&#10;        val userLocation = currentState.userLocation&#10;        if (userLocation != null &amp;&amp; currentState.selectedFilter == &quot;terdekat&quot;) {&#10;            filteredBooks = filteredBooks.filter { book -&gt;&#10;                if (book.lat != null &amp;&amp; book.lng != null) {&#10;                    val distance = calculateDistanceInKm(&#10;                        userLocation.latitude,&#10;                        userLocation.longitude,&#10;                        book.lat,&#10;                        book.lng&#10;                    )&#10;                    distance &lt;= 25.0 // Maksimal 25km sesuai dengan filter chip&#10;                } else {&#10;                    false // Hilangkan buku yang tidak memiliki koordinat&#10;                }&#10;            }.sortedBy { book -&gt;&#10;                // Sort berdasarkan jarak terdekat&#10;                if (book.lat != null &amp;&amp; book.lng != null) {&#10;                    calculateDistanceInKm(&#10;                        userLocation.latitude,&#10;                        userLocation.longitude,&#10;                        book.lat,&#10;                        book.lng&#10;                    )&#10;                } else {&#10;                    Double.MAX_VALUE&#10;                }&#10;            }&#10;        } else if (currentState.selectedFilter == &quot;terbaru&quot;) {&#10;            // ✅ FILTER 4: Sort berdasarkan tanggal terbaru&#10;            filteredBooks = filteredBooks.sortedByDescending { it.createdAt.toDate().time }&#10;        }&#10;&#10;        return filteredBooks&#10;    }&#10;&#10;    private fun calculateDistanceInKm(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Double {&#10;        val earthRadius = 6371.0&#10;        val dLat = Math.toRadians(lat2 - lat1)&#10;        val dLng = Math.toRadians(lng2 - lng1)&#10;        val a = sin(dLat / 2) * sin(dLat / 2) +&#10;                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *&#10;                sin(dLng / 2) * sin(dLng / 2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.arsip.ui.home&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.arsip.data.Book&#10;import com.example.arsip.data.BooksRepository&#10;import com.example.arsip.data.ProfileRepository&#10;import com.google.android.gms.maps.model.LatLng&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import kotlin.math.atan2&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;import kotlin.math.sqrt&#10;&#10;data class HomeState(&#10;    val userName: String = &quot;User&quot;,&#10;    val userPhotoUrl: String? = null,&#10;    val searchQuery: String = &quot;&quot;,&#10;    val selectedFilter: String = &quot;terdekat&quot;,&#10;    val radiusKm: Float = 5f,&#10;    val userLocation: LatLng? = null,&#10;    val allBooks: List&lt;Book&gt; = emptyList(),&#10;    val nearbyBooks: List&lt;Book&gt; = emptyList(),&#10;    val highlightedBooks: List&lt;Book&gt; = emptyList(),&#10;    val isLoading: Boolean = true,&#10;    val errorMessage: String? = null&#10;) {&#10;    fun calculateDistance(book: Book): String {&#10;        if (userLocation == null || book.lat == null || book.lng == null) {&#10;            return book.addressText.split(&quot;,&quot;).firstOrNull()?.trim() ?: &quot;Lokasi tidak diketahui&quot;&#10;        }&#10;&#10;        val distance = calculateDistanceInKm(&#10;            userLocation.latitude,&#10;            userLocation.longitude,&#10;            book.lat,&#10;            book.lng&#10;        )&#10;&#10;        return when {&#10;            distance &lt; 1.0 -&gt; &quot;${(distance * 1000).toInt()} m&quot;&#10;            distance &lt; 10.0 -&gt; String.format(&quot;%.1f km&quot;, distance)&#10;            else -&gt; &quot;${distance.toInt()} km&quot;&#10;        }&#10;    }&#10;&#10;    private fun calculateDistanceInKm(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Double {&#10;        val earthRadius = 6371.0&#10;        val dLat = Math.toRadians(lat2 - lat1)&#10;        val dLng = Math.toRadians(lng2 - lng1)&#10;        val a = sin(dLat / 2) * sin(dLat / 2) +&#10;                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *&#10;                sin(dLng / 2) * sin(dLng / 2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;}&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val booksRepository: BooksRepository,&#10;    private val profileRepository: ProfileRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(HomeState())&#10;    val state: StateFlow&lt;HomeState&gt; = _state.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            try {&#10;                loadUserProfile()&#10;                loadBooks()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Init error&quot;, e)&#10;                _state.update { it.copy(isLoading = false, userName = &quot;User&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            try {&#10;                profileRepository.meFlow()&#10;                    .catch { e -&gt;&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error loading profile&quot;, e)&#10;                        emit(null)&#10;                    }&#10;                    .collectLatest { userProfile -&gt;&#10;                        // ✅ FIXED: Use real user location from database&#10;                        val userLocation = if (userProfile?.latitude != null &amp;&amp; userProfile?.longitude != null &amp;&amp;&#10;                            userProfile.latitude != 0.0 &amp;&amp; userProfile.longitude != 0.0) {&#10;                            LatLng(userProfile.latitude, userProfile.longitude)&#10;                        } else {&#10;                            // Default ke Jakarta jika tidak ada lokasi user&#10;                            LatLng(-6.2088, 106.8456)&#10;                        }&#10;&#10;                        _state.update {&#10;                            it.copy(&#10;                                userName = userProfile?.displayName?.ifBlank { &quot;User&quot; } ?: &quot;User&quot;,&#10;                                userPhotoUrl = userProfile?.photoUrl,&#10;                                userLocation = userLocation&#10;                            )&#10;                        }&#10;&#10;                        // ✅ FIXED: Reapply filters immediately when user location changes&#10;                        applyFilters()&#10;                    }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error in loadUserProfile&quot;, e)&#10;                _state.update {&#10;                    it.copy(&#10;                        userName = &quot;User&quot;,&#10;                        userLocation = LatLng(-6.2088, 106.8456) // Default Jakarta&#10;                    )&#10;                }&#10;                // Apply filters even with default location&#10;                applyFilters()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadBooks() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _state.update { it.copy(isLoading = true, errorMessage = null) }&#10;&#10;                booksRepository.allBooksFlow()&#10;                    .catch { e -&gt;&#10;                        Log.e(&quot;HomeViewModel&quot;, &quot;Error loading books&quot;, e)&#10;                        emit(emptyList())&#10;                    }&#10;                    .collectLatest { books -&gt;&#10;                        try {&#10;                            val filtered = filterBooks(books)&#10;                            _state.update { currentState -&gt;&#10;                                currentState.copy(&#10;                                    allBooks = books,&#10;                                    nearbyBooks = filtered,&#10;                                    highlightedBooks = books.filter { it.isAvailable }.take(5),&#10;                                    isLoading = false,&#10;                                    errorMessage = null&#10;                                )&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;HomeViewModel&quot;, &quot;Error filtering books&quot;, e)&#10;                            _state.update {&#10;                                it.copy(&#10;                                    allBooks = books,&#10;                                    nearbyBooks = books,&#10;                                    highlightedBooks = books.take(5),&#10;                                    isLoading = false&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;HomeViewModel&quot;, &quot;Error in loadBooks&quot;, e)&#10;                _state.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        errorMessage = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onSearchQueryChange(query: String) {&#10;        _state.update { it.copy(searchQuery = query) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onFilterSelect(filter: String) {&#10;        _state.update { it.copy(selectedFilter = filter) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onRadiusChange(radius: Float) {&#10;        _state.update { it.copy(radiusKm = radius) }&#10;        applyFilters()&#10;    }&#10;&#10;    fun onLocationPermissionGranted() {&#10;        val defaultLocation = LatLng(-6.2088, 106.8456)&#10;        _state.update { it.copy(userLocation = defaultLocation) }&#10;        applyFilters()&#10;    }&#10;&#10;    private fun applyFilters() {&#10;        try {&#10;            val currentState = _state.value&#10;            val filtered = filterBooks(currentState.allBooks)&#10;            _state.update { it.copy(nearbyBooks = filtered) }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;HomeViewModel&quot;, &quot;Error applying filters&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun filterBooks(books: List&lt;Book&gt;): List&lt;Book&gt; {&#10;        val currentState = _state.value&#10;&#10;        // ✅ FILTER 1: Hanya tampilkan buku yang tersedia (isAvailable = true)&#10;        var filteredBooks = books.filter { it.isAvailable }&#10;&#10;        // ✅ FILTER 2: Filter berdasarkan search query&#10;        if (currentState.searchQuery.isNotBlank()) {&#10;            val query = currentState.searchQuery.lowercase()&#10;            filteredBooks = filteredBooks.filter { book -&gt;&#10;                book.title.lowercase().contains(query) ||&#10;                        book.author.lowercase().contains(query) ||&#10;                        book.category.lowercase().contains(query) ||&#10;                        book.desc.lowercase().contains(query)&#10;            }&#10;        }&#10;&#10;        // ✅ FILTER 3: Filter berdasarkan lokasi user dan jarak maksimal&#10;        val userLocation = currentState.userLocation&#10;        if (userLocation != null &amp;&amp; currentState.selectedFilter == &quot;terdekat&quot;) {&#10;            filteredBooks = filteredBooks.filter { book -&gt;&#10;                if (book.lat != null &amp;&amp; book.lng != null) {&#10;                    val distance = calculateDistanceInKm(&#10;                        userLocation.latitude,&#10;                        userLocation.longitude,&#10;                        book.lat,&#10;                        book.lng&#10;                    )&#10;                    distance &lt;= 25.0 // Maksimal 25km sesuai dengan filter chip&#10;                } else {&#10;                    false // Hilangkan buku yang tidak memiliki koordinat&#10;                }&#10;            }.sortedBy { book -&gt;&#10;                // Sort berdasarkan jarak terdekat&#10;                if (book.lat != null &amp;&amp; book.lng != null) {&#10;                    calculateDistanceInKm(&#10;                        userLocation.latitude,&#10;                        userLocation.longitude,&#10;                        book.lat,&#10;                        book.lng&#10;                    )&#10;                } else {&#10;                    Double.MAX_VALUE&#10;                }&#10;            }&#10;        } else if (currentState.selectedFilter == &quot;terbaru&quot;) {&#10;            // ✅ FILTER 4: Sort berdasarkan tanggal terbaru&#10;            filteredBooks = filteredBooks.sortedByDescending { it.createdAt.toDate().time }&#10;        }&#10;&#10;        return filteredBooks&#10;    }&#10;&#10;    private fun calculateDistanceInKm(lat1: Double, lng1: Double, lat2: Double, lng2: Double): Double {&#10;        val earthRadius = 6371.0&#10;        val dLat = Math.toRadians(lat2 - lat1)&#10;        val dLng = Math.toRadians(lng2 - lng1)&#10;        val a = sin(dLat / 2) * sin(dLat / 2) +&#10;                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *&#10;                sin(dLng / 2) * sin(dLng / 2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/arsip/ui/profile/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/arsip/ui/profile/ProfileViewModel.kt" />
              <option name="originalContent" value="package com.example.arsip.ui.profile&#10;&#10;import android.net.Uri&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.arsip.data.ImageUploader&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.DocumentSnapshot&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import com.google.firebase.firestore.SetOptions&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val auth: FirebaseAuth,&#10;    private val db: FirebaseFirestore,&#10;    private val uploader: ImageUploader&#10;) : ViewModel() {&#10;&#10;    var name by mutableStateOf(&quot;&quot;)&#10;    var busy by mutableStateOf(false)&#10;&#10;    var tmpAddr by mutableStateOf(&quot;&quot;)&#10;    var tmpLat by mutableStateOf(&quot;&quot;)&#10;    var tmpLng by mutableStateOf(&quot;&quot;)&#10;&#10;    private val _snap = MutableStateFlow&lt;DocumentSnapshot?&gt;(null)&#10;    val snap: StateFlow&lt;DocumentSnapshot?&gt; = _snap&#10;&#10;    private var reg: ListenerRegistration? = null&#10;&#10;    init {&#10;        val uid = auth.currentUser?.uid&#10;        if (uid != null) {&#10;            reg = db.collection(&quot;users&quot;).document(uid)&#10;                .addSnapshotListener { ds, _ -&gt;&#10;                    _snap.value = ds&#10;                    tmpAddr = ds?.getString(&quot;addressText&quot;) ?: &quot;&quot;&#10;                    tmpLat  = ds?.getDouble(&quot;lat&quot;)?.toString() ?: &quot;&quot;&#10;                    tmpLng  = ds?.getDouble(&quot;lng&quot;)?.toString() ?: &quot;&quot;&#10;                }&#10;        }&#10;    }&#10;&#10;    // FUNGSI BARU: Untuk menerima update LatLng dari map picker&#10;    fun onLatLngSelected(lat: Double?, lng: Double?) {&#10;        tmpLat = lat?.toString() ?: &quot;&quot;&#10;        tmpLng = lng?.toString() ?: &quot;&quot;&#10;    }&#10;&#10;    fun saveName() = viewModelScope.launch {&#10;        val uid = auth.currentUser?.uid ?: return@launch&#10;        val currentName = _snap.value?.getString(&quot;displayName&quot;) ?: &quot;&quot;&#10;        val newName = if (name.isBlank()) currentName else name&#10;&#10;        busy = true&#10;        runCatching {&#10;            db.collection(&quot;users&quot;).document(uid)&#10;                .set(mapOf(&quot;displayName&quot; to newName), SetOptions.merge())&#10;                .await()&#10;        }.onSuccess {&#10;            name = &quot;&quot; // reset input&#10;        }.also {&#10;            busy = false&#10;        }&#10;    }&#10;&#10;    fun updatePhoto(uri: Uri) = viewModelScope.launch {&#10;        val uid = auth.currentUser?.uid ?: return@launch&#10;        busy = true&#10;        runCatching {&#10;            val url = uploader.uploadOne(uri)&#10;            db.collection(&quot;users&quot;).document(uid)&#10;                .set(mapOf(&quot;photoUrl&quot; to url), SetOptions.merge())&#10;                .await()&#10;        }.also {&#10;            busy = false&#10;        }&#10;    }&#10;&#10;    fun saveAddress() = viewModelScope.launch {&#10;        val uid = auth.currentUser?.uid ?: return@launch&#10;        busy = true&#10;        runCatching {&#10;            val data = hashMapOf&lt;String, Any?&gt;(&#10;                &quot;addressText&quot; to tmpAddr,&#10;                &quot;lat&quot; to tmpLat.toDoubleOrNull(),&#10;                &quot;lng&quot; to tmpLng.toDoubleOrNull()&#10;            )&#10;            db.collection(&quot;users&quot;).document(uid)&#10;                .set(data, SetOptions.merge())&#10;                .await()&#10;        }.also {&#10;            busy = false&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        auth.signOut()&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        reg?.remove()&#10;        reg = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.arsip.ui.profile&#13;&#10;&#13;&#10;import android.net.Uri&#13;&#10;import androidx.compose.runtime.getValue&#13;&#10;import androidx.compose.runtime.mutableStateOf&#13;&#10;import androidx.compose.runtime.setValue&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.arsip.upload.ImageUploader&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.DocumentSnapshot&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.ListenerRegistration&#13;&#10;import com.google.firebase.firestore.SetOptions&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class ProfileViewModel @Inject constructor(&#13;&#10;    private val auth: FirebaseAuth,&#13;&#10;    private val db: FirebaseFirestore,&#13;&#10;    private val uploader: ImageUploader&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    var name by mutableStateOf(&quot;&quot;)&#13;&#10;    var busy by mutableStateOf(false)&#13;&#10;&#13;&#10;    var tmpAddr by mutableStateOf(&quot;&quot;)&#13;&#10;    var tmpLat by mutableStateOf(&quot;&quot;)&#13;&#10;    var tmpLng by mutableStateOf(&quot;&quot;)&#13;&#10;&#13;&#10;    private val _snap = MutableStateFlow&lt;DocumentSnapshot?&gt;(null)&#13;&#10;    val snap: StateFlow&lt;DocumentSnapshot?&gt; = _snap&#13;&#10;&#13;&#10;    private var reg: ListenerRegistration? = null&#13;&#10;&#13;&#10;    init {&#13;&#10;        val uid = auth.currentUser?.uid&#13;&#10;        if (uid != null) {&#13;&#10;            reg = db.collection(&quot;users&quot;).document(uid)&#13;&#10;                .addSnapshotListener { ds, _ -&gt;&#13;&#10;                    _snap.value = ds&#13;&#10;                    tmpAddr = ds?.getString(&quot;addressText&quot;) ?: &quot;&quot;&#13;&#10;                    tmpLat  = ds?.getDouble(&quot;lat&quot;)?.toString() ?: &quot;&quot;&#13;&#10;                    tmpLng  = ds?.getDouble(&quot;lng&quot;)?.toString() ?: &quot;&quot;&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // FUNGSI BARU: Untuk menerima update LatLng dari map picker&#13;&#10;    fun onLatLngSelected(lat: Double?, lng: Double?) {&#13;&#10;        tmpLat = lat?.toString() ?: &quot;&quot;&#13;&#10;        tmpLng = lng?.toString() ?: &quot;&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    fun saveName() = viewModelScope.launch {&#13;&#10;        val uid = auth.currentUser?.uid ?: return@launch&#13;&#10;        val currentName = _snap.value?.getString(&quot;displayName&quot;) ?: &quot;&quot;&#13;&#10;        val newName = if (name.isBlank()) currentName else name&#13;&#10;&#13;&#10;        busy = true&#13;&#10;        runCatching {&#13;&#10;            db.collection(&quot;users&quot;).document(uid)&#13;&#10;                .set(mapOf(&quot;displayName&quot; to newName), SetOptions.merge())&#13;&#10;                .await()&#13;&#10;        }.onSuccess {&#13;&#10;            name = &quot;&quot; // reset input&#13;&#10;        }.also {&#13;&#10;            busy = false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updatePhoto(uri: Uri) = viewModelScope.launch {&#13;&#10;        val uid = auth.currentUser?.uid ?: return@launch&#13;&#10;        busy = true&#13;&#10;        runCatching {&#13;&#10;            val url = uploader.uploadOne(uri)&#13;&#10;            db.collection(&quot;users&quot;).document(uid)&#13;&#10;                .set(mapOf(&quot;photoUrl&quot; to url), SetOptions.merge())&#13;&#10;                .await()&#13;&#10;        }.also {&#13;&#10;            busy = false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun saveAddress() = viewModelScope.launch {&#13;&#10;        val uid = auth.currentUser?.uid ?: return@launch&#13;&#10;        busy = true&#13;&#10;        runCatching {&#13;&#10;            val data = hashMapOf&lt;String, Any?&gt;(&#13;&#10;                &quot;addressText&quot; to tmpAddr,&#13;&#10;                &quot;lat&quot; to tmpLat.toDoubleOrNull(),&#13;&#10;                &quot;lng&quot; to tmpLng.toDoubleOrNull()&#13;&#10;            )&#13;&#10;            db.collection(&quot;users&quot;).document(uid)&#13;&#10;                .set(data, SetOptions.merge())&#13;&#10;                .await()&#13;&#10;        }.also {&#13;&#10;            busy = false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun logout() {&#13;&#10;        auth.signOut()&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onCleared() {&#13;&#10;        super.onCleared()&#13;&#10;        reg?.remove()&#13;&#10;        reg = null&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>